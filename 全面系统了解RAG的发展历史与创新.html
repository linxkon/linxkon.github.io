

<!DOCTYPE html>
<html lang="zh-CN" data-default-color-scheme=auto>



<head>
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="/img/linxkon_blog.png">
  <link rel="icon" href="/img/linxkon_blog.png">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="author" content="linxkon">
  <meta name="keywords" content="技术分享，项目实战，生活记录">
  
    <meta name="description" content="1. RAG系统的发展历史与问题 RAG（检索增强生成）通过访问外部知识库，检索增强生成（RAG）为 LLMs 提供了关键的上下文信息，极大地提升了其在知识密集型任务上的表现。RAG 作为一种增强手段，已在众多实际应用场景中广泛运用，涵盖知识问答、推荐系统、客户服务以及个人助手等领域。 RAG 技术的发展可归结为三个阶段：  • 起初，检索增强技术被引入，提升预训练语言模型在知识密集">
<meta property="og:type" content="article">
<meta property="og:title" content="AI·你所爱">
<meta property="og:url" content="https://linxkon.github.io/%E5%85%A8%E9%9D%A2%E7%B3%BB%E7%BB%9F%E4%BA%86%E8%A7%A3RAG%E7%9A%84%E5%8F%91%E5%B1%95%E5%8E%86%E5%8F%B2%E4%B8%8E%E5%88%9B%E6%96%B0.html">
<meta property="og:site_name" content="AI·你所爱">
<meta property="og:description" content="1. RAG系统的发展历史与问题 RAG（检索增强生成）通过访问外部知识库，检索增强生成（RAG）为 LLMs 提供了关键的上下文信息，极大地提升了其在知识密集型任务上的表现。RAG 作为一种增强手段，已在众多实际应用场景中广泛运用，涵盖知识问答、推荐系统、客户服务以及个人助手等领域。 RAG 技术的发展可归结为三个阶段：  • 起初，检索增强技术被引入，提升预训练语言模型在知识密集">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2024-08-17T02:09:43.634Z">
<meta property="article:modified_time" content="2024-08-19T04:56:27.038Z">
<meta property="article:author" content="linxkon">
<meta property="article:tag" content="技术分享，项目实战，生活记录">
<meta name="twitter:card" content="summary_large_image">
  
  
  
  <title>AI·你所爱</title>

  <link  rel="stylesheet" href="https://lib.baomitu.com/twitter-bootstrap/4.6.1/css/bootstrap.min.css" />



  <link  rel="stylesheet" href="https://lib.baomitu.com/github-markdown-css/4.0.0/github-markdown.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/hint.css/2.7.0/hint.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css" />



<!-- 主题依赖的图标库，不要自行修改 -->
<!-- Do not modify the link that theme dependent icons -->

<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_hj8rtnfg7um.css">



<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_lbnruvf0jn.css">


<link  rel="stylesheet" href="/css/main.css" />


  <link id="highlight-css" rel="stylesheet" href="/css/highlight.css" />
  
    <link id="highlight-css-dark" rel="stylesheet" href="/css/highlight-dark.css" />
  




  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    Fluid.ctx = Object.assign({}, Fluid.ctx)
    var CONFIG = {"hostname":"linxkon.github.io","root":"/","version":"1.9.7","typing":{"enable":true,"typeSpeed":70,"cursorChar":"_","loop":false,"scope":[]},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"left","visible":"hover","icon":""},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"code_language":{"enable":true,"default":"TEXT"},"copy_btn":true,"image_caption":{"enable":true},"image_zoom":{"enable":true,"img_url_replace":["",""]},"toc":{"enable":true,"placement":"right","headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"lazyload":{"enable":true,"loading_img":"/img/loading.gif","onlypost":false,"offset_factor":2},"web_analytics":{"enable":true,"follow_dnt":true,"baidu":null,"google":{"measurement_id":null},"tencent":{"sid":null,"cid":null},"woyaola":null,"cnzz":null,"leancloud":{"enable":true,"app_id":"XLEbEr6BfzRRh34xJtmOEom0-MdYXbMMI","app_key":"3bwflR7evMRYC6JTohHAE31C","server_url":null,"path":"window.location.pathname","ignore_local":false}},"search_path":"/local-search.xml","include_content_in_search":true};

    if (CONFIG.web_analytics.follow_dnt) {
      var dntVal = navigator.doNotTrack || window.doNotTrack || navigator.msDoNotTrack;
      Fluid.ctx.dnt = dntVal && (dntVal.startsWith('1') || dntVal.startsWith('yes') || dntVal.startsWith('on'));
    }
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>
  

  

  
    <!-- Google tag (gtag.js) -->
    <script async>
      if (!Fluid.ctx.dnt) {
        Fluid.utils.createScript("https://www.googletagmanager.com/gtag/js?id=", function() {
          window.dataLayer = window.dataLayer || [];
          function gtag() {
            dataLayer.push(arguments);
          }
          gtag('js', new Date());
          gtag('config', '');
        });
      }
    </script>
  

  

  

  

  
    
  



  
<meta name="generator" content="Hexo 7.1.1"></head>


<body>
  

  <header>
    

<div class="header-inner" style="height: 70vh;">
  <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand" href="/">
      <strong>AI·你所爱 | Linxkon@gmail.com</strong>
    </a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/" target="_self">
                <i class="iconfont icon-home-fill"></i>
                <span>首页</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/" target="_self">
                <i class="iconfont icon-archive-fill"></i>
                <span>归档</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/" target="_self">
                <i class="iconfont icon-category-fill"></i>
                <span>分类</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/" target="_self">
                <i class="iconfont icon-tags-fill"></i>
                <span>标签</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/" target="_self">
                <i class="iconfont icon-user-fill"></i>
                <span>关于</span>
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search">
              <i class="iconfont icon-search"></i>
            </a>
          </li>
          
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle">
              <i class="iconfont icon-dark" id="color-toggle-icon"></i>
            </a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

  

<div id="banner" class="banner" parallax=true
     style="background: url('/img/pursenight.png') no-repeat center center; background-size: cover;">
  <div class="full-bg-img">
    <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
      <div class="banner-text text-center fade-in-up">
        <div class="h2">
          
            <span id="subtitle" data-typed-text=""></span>
          
        </div>

        
          
  <div class="mt-3">
    
    
      <span class="post-meta">
        <i class="iconfont icon-date-fill" aria-hidden="true"></i>
        <time datetime="2024-08-17 10:09" pubdate>
          2024年8月17日 上午
        </time>
      </span>
    
  </div>

  <div class="mt-1">
    
      <span class="post-meta mr-2">
        <i class="iconfont icon-chart"></i>
        
          9.4k 字
        
      </span>
    

    
      <span class="post-meta mr-2">
        <i class="iconfont icon-clock-fill"></i>
        
        
        
          79 分钟
        
      </span>
    

    
    
      
        <span id="leancloud-page-views-container" class="post-meta" style="display: none">
          <i class="iconfont icon-eye" aria-hidden="true"></i>
          <span id="leancloud-page-views"></span> 次
        </span>
        
      
    
  </div>


        
      </div>

      
    </div>
  </div>
</div>

</div>

  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="side-col d-none d-lg-block col-lg-2">
      

    </div>

    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div id="board">
          <article class="post-content mx-auto">
            <h1 id="seo-header"></h1>
            
            
              <div class="markdown-body">
                
                <h2 id="rag系统的发展历史与问题">1. RAG系统的发展历史与问题</h2>
<p>RAG（检索增强生成）通过访问外部知识库，检索增强生成（RAG）为 LLMs
提供了关键的上下文信息，极大地提升了其在知识密集型任务上的表现。RAG
作为一种增强手段，已在众多实际应用场景中广泛运用，涵盖知识问答、推荐系统、客户服务以及个人助手等领域。</p>
<p>RAG 技术的发展可归结为三个阶段：</p>
<ul>
<li><p>•
起初，检索增强技术被引入，提升预训练语言模型在知识密集型任务上的表现。比如：</p>
<ul>
<li>• Retro 通过检索增强优化了预训练的自回归模型。</li>
<li>• Atlas
则运用了检索增强的少样本微调手段，使语言模型能适应各类任务。</li>
<li>• IRcot
通过融合思维链和多步检索流程，进一步丰富了推理阶段的推理过程。</li>
</ul></li>
<li><p>•
第二阶段，随着大型语言模型（LLM）的语言处理能力大幅提升，检索增强技术开始充当补充额外知识和提供参考的途径，以减少幻觉。例如：</p>
<ul>
<li>• RRR 改进了重写阶段</li>
<li>• LLMlingua 去除了检索所得文档块中的冗余标记。</li>
</ul></li>
<li><p>• 随着 RAG
技术的持续进步，研究愈发精细且集中，实现了与<strong>图神经网络和微调技术</strong>等其他技术的创新融合。整体流程也更趋灵活，比如利用大型语言模型主动确定检索和生成的时机
。</p></li>
</ul>
<blockquote>
<p>几乎每一篇讨论RAG的论文都会讨论RAG存在的问题。</p>
</blockquote>
<p>RAG 发展初期，其核心框架由索引、检索和生成构成，这种范式被称作朴素
RAG。随着任务复杂程度和应用需求的提升，朴素 RAG 的局限性愈发凸显。</p>
<figure>
<img
src="https://mmbiz.qpic.cn/mmbiz_png/ZPAyBwf6Hyj1RN6oLRRFiawc94IDAXSL0NZXnUXkianW2LACa9ptsQVqL08Wd12yOEaak4oiaEaxzKMNwM7MdS7PQ/640?wx_fmt=png&amp;from=appmsg&amp;tp=wxpic&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" srcset="/img/loading.gif" lazyload
alt="图片" />
<figcaption aria-hidden="true">图片</figcaption>
</figure>
<p>如上图所示，朴素RAG主要依赖于块的简单相似性，在应对复杂查询和具有显著变异性的块时，表现欠佳。</p>
<p>朴素 RAG 存在的问题主要包括：</p>
<ul>
<li>• <strong>1）对查询的理解不够深入。</strong>
查询和文档块之间的语义相似度并非总是高度一致。仅依靠相似度计算进行检索，缺乏对查询与文档间关系的深度探究。</li>
<li>• <strong>2）检索存在冗余和噪声。</strong>
将所有检索到的块直接输入到 LLMs
并非总是有益。研究表明，过多的冗余和噪声信息可能会干扰 LLM
对关键信息的识别，从而增加生成错误和幻觉响应的风险。</li>
</ul>
<p>为了克服以上局限，大家提出了高级RAG，高级RAG注重优化检索阶段，旨在提升检索效率，并强化对检索块的利用，典型策略涵盖预检索处理和后检索处理。例如，采用查询重写使查询更清晰、具体，进而提高检索的精准度，对检索结果进行重新排序以增强
LLM 识别和利用关键信息的能力。</p>
<p>尽管高级RAG有所改进，但是仍然与实际应用与需求之间存在差距：随着 RAG
技术的发展，用户期望提高，需求持续演变，应用设置也变得更为复杂。例如，异构数据的整合以及对系统透明度、控制和可维护性的新需求。</p>
<p>为达成更精准和高效的任务执行，现代 RAG
系统正逐步融合更复杂的功能，比如以<strong>知识图谱</strong>的形式构建更精细的索引库，通过查询构建方法<strong>整合结构化数据</strong>，以及<strong>运用微调技术让编码器更好地适应特定领域的文档</strong>。</p>
<p>在流程设计方面，当前的 RAG
系统<strong>已超越传统的线性检索生成范式</strong>。研究人员采用迭代检索获取更丰富的上下文，利用递归检索处理复杂查询，以及借助自适应检索提供整体的自主性和灵活性。这种流程上的灵活性显著增强了
RAG
系统的表达力和适应性，使其能更好地适应各类应用场景。然而这使得RAG系统的架构越来越复杂，越来越多的新问题不断出现：</p>
<ul>
<li>• <strong>复杂数据源集成</strong>：RAG
不再局限于单一的非结构化文本数据源类型，而是拓展至涵盖诸如表格之类的半结构化数据以及像知识图谱这样的结构化数据。获取来自多个来源的异构数据，能够为系统赋予更丰富的知识背景以及更可靠的知识验证能力。</li>
</ul>
<p><strong>可解释性、可控性和可维护性方面的新需求</strong>：随着系统复杂度的提升，系统维护和调试变得更具挑战。此外，当问题出现时，必须迅速锁定需要优化的特定组件。</p>
<p><strong>组件的选择与优化</strong>：更多的神经网络融入 RAG
系统，需要挑选适宜的组件以满足特定任务和资源配置的需求。而且，新的组件虽提升了
RAG
的效能，但也带来了新的协作工作要求。确保这些模型按预期运行并高效协同，以提升整体系统性能，这一点至关重要。</p>
<p><strong>工作流的编排与调度</strong>：组件可能需要依照特定顺序执行，在某些条件下并行处理，甚至由
LLM
根据不同的输出进行判定。对工作流进行合理规划，对于提高系统效率和达成预期成果至关重要。</p>
<p>为了应对以上这些问题，今天这篇论文作者提出了模块化 RAG 架构。</p>
<h2 id="什么是模块化rag架构">2. 什么是模块化RAG架构？</h2>
<figure>
<img
src="https://mmbiz.qpic.cn/mmbiz_png/ZPAyBwf6Hyj1RN6oLRRFiawc94IDAXSL0IjUq6p01GGmoz7JTOCCuWYBeiaViatAaRibbjPmYFr7I5kmqpfgCWWn7A/640?wx_fmt=png&amp;from=appmsg&amp;tp=wxpic&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" srcset="/img/loading.gif" lazyload
alt="图片" />
<figcaption aria-hidden="true">图片</figcaption>
</figure>
<p>在现代计算系统中，模块化正成为一种趋势。能够增强系统的可扩展性和可维护性，并通过流程控制实现高效的任务执行。模块化
RAG 架构分为三个层级：</p>
<ul>
<li>• 顶层聚焦于 RAG
的关键阶段，其中每个阶段都视作一个独立的模块。该层级不仅继承了高级 RAG
范式的主要流程，还引入了一个编排模块来调控 RAG 流程的协同。</li>
<li>• 中间层由每个模块内的子模块组成，进一步细化和优化功能。</li>
<li>• 底层由基本操作单元——操作符构成。</li>
</ul>
<figure>
<img
src="https://mmbiz.qpic.cn/mmbiz_png/ZPAyBwf6Hyj1RN6oLRRFiawc94IDAXSL0XgibPqds3Vcu8etz72OF4f91sSa31dcicqlD5aVSwZ1tQFOnFK5xCQIQ/640?wx_fmt=png&amp;from=appmsg&amp;tp=wxpic&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" srcset="/img/loading.gif" lazyload
alt="图片" />
<figcaption aria-hidden="true">图片</figcaption>
</figure>
<p>在模块化 RAG 框架内，RAG
系统能够以计算图的形式呈现，其中节点代表特定的操作符。模块化 RAG 是在
RAG
先前发展的基础上演化而来的。这三个范式（朴素RAG、高级RAG和模块化RAG）之间的关系是继承与发展的关系。高级
RAG 是模块化 RAG 的一种特殊情形，而朴素 RAG 是高级 RAG
的一种特殊情形。</p>
<h2 id="六大模块">3. 六大模块</h2>
<p>模块化RAG包括六个主要模块：索引、预检索、检索、后检索、生成和编排。</p>
<h3 id="索引indexing">3.1 索引（Indexing）</h3>
<p>索引指的是把文档分割为可管理的块的过程，是组织系统的关键步骤。</p>
<p>索引面临着三个主要难题。</p>
<ul>
<li>•1. 内容表述不完整。</li>
<li>块的语义信息受分割方式影响，致使在较长的语境中重要信息的丢失或被掩盖。</li>
<li>•2. 块相似性搜索不准确。</li>
<li>随着数据量增多，检索中的噪声增大，导致频繁与错误数据匹配，使得检索系统脆弱且不可靠。</li>
<li>•3. 参考轨迹不明晰。</li>
<li>检索到的块可能来自任何文档，没有引用痕迹，可能出现来自多个不同文档的块，尽管语义相似，但包含的却是完全不同主题的内容。</li>
</ul>
<h4 id="块优化">3.1.1 块优化</h4>
<p>块的大小以及块之间的重叠，在 RAG 系统的整体有效性中起着关键作用：</p>
<ul>
<li>•
较大的块能捕捉更多的上下文，但也会产生更多噪声，需要更长的处理时间和更高的成本。</li>
<li>• 而较小的块可能无法完整传达必要的上下文，不过噪声较小。</li>
</ul>
<p><strong>滑动窗口</strong>：在滑动窗口中使用重叠块能增强语义转换。这种方法也存在一些局限性，如上下文大小控制不精准、单词或句子可能被截断以及缺乏语义考量等。</p>
<p><strong>增加元数据</strong>：块可以用元数据（比如页码、文件名、作者、时间戳、摘要或相关问题）进行丰富。这些元数据允许进行筛选检索，缩小搜索范围。</p>
<p><strong>从小到大</strong>：将用于检索的块和用于合成的块区分开。较小的块能提高检索的准确性，较大的块能提供更多的上下文。一种方法是检索较小的总结块，并参考其较大的父块。或者，可以检索单个句子及其周边的文本。</p>
<h4 id="结构组织">3.1.2 结构组织</h4>
<p>增强信息检索的一种有效方式是为文档构建层次结构。通过构建块结构，RAG
系统能够加快相关数据的检索和处理。</p>
<p><strong>分层索引</strong>：在文档的分层结构中，节点按父子关系排列，并与块相连接。每个节点都存储着数据摘要，有助于快速遍历数据，并协助
RAG
系统确定要提取哪些块。这种方法还能减轻因块提取问题产生的错觉。构建结构化索引的方法主要包括：</p>
<ul>
<li>•1. 基于文档中的段落和句子分割的结构。</li>
<li>•2. 基于 PDF、HTML 和 Latex 中固有结构。</li>
<li>•3. 基于文本语义识别和分割的语义。</li>
</ul>
<p><strong>KG
索引</strong>：使用知识图（KGs）来构建文档有助于通过厘清概念和实体之间的联系来保持一致性，降低不匹配错误的风险。还能将信息检索转化为语言模型可理解的指令，提高检索的准确性并实现上下文连贯的响应。这提升了
RAG 系统的整体效率。</p>
<h3 id="预检索pre-retrieval">3.2 预检索（Pre-retrieval）</h3>
<p>朴素 RAG
的一大主要挑战在于它直接将用户的原始查询当作检索的基础。制定精确清晰的问题颇具难度，欠妥的查询会致使检索效果欠佳。此模块的主要挑战包含：</p>
<ul>
<li>• 1）查询措辞不当。问题本身复杂，语言组织欠佳。</li>
<li>•
2）语言的复杂性与歧义性。语言模型在应对专业词汇或含义多样的模糊缩写时常常遭遇困境。比如，它们或许无法判别
LLM 指的是大型语言模型还是法律语境中的法学硕士。</li>
</ul>
<h4 id="查询扩展">3.2.1 查询扩展</h4>
<p>将单个查询拓展为<strong>多个查询</strong>，丰富了查询内容，为弥补特定细微差异的缺失提供了更多上下文，从而确保生成答案的最佳相关性。</p>
<p><strong>多查询</strong>：借助提示工程通过大型语言模型来扩展查询，而且并行执行。这些扩展经过精心设计以保障多样性和覆盖度。不过，这种方式可能会<strong>淡化用户的原始意图</strong>。为减轻这一情况，可指示模型给予原始查询更大的权重。</p>
<p><strong>子查询</strong>：通过分解和规划复杂问题，会生成多个子问题。具体而言，可以采用从少到多的提示来将复杂问题分解为一系列更简单的子问题。依照原始问题的结构，生成的子问题能够并行或顺序执行。另一种方法涉及使用验证链（CoVe）。扩展后的查询由大型语言模型进行验证，以达成减少幻觉的效果。</p>
<h4 id="查询转换">3.2.2 查询转换</h4>
<p>依据转换后的查询而非用户的原始查询进行检索和生成。</p>
<p><strong>重写（Rewrite）</strong>：原始查询在现实场景中的检索常常存在不足。为解决此问题，可以提示大型语言模型进行重写。也可运用专门的较小模型来达成此目的
。<strong>淘宝中查询重写方法的实施显著提升了长尾查询的召回效果，促使 GMV
增长 </strong>。</p>
<p><strong>HyDE</strong>：为弥合问题与答案之间的语义差距，它在回应查询时构建假设文档（假设答案），而非直接搜索查询。它侧重于从答案到答案的嵌入相似性，而非寻求针对问题或查询的嵌入相似性。此外，它还包含反向
HyDE，为每个块生成假设查询，并专注于从查询到查询的检索。</p>
<p><strong>回退提示（Step-back
Prompting）</strong>：原始查询被抽象为一个高级概念问题（回退问题）。在
RAG
系统中，回退问题和原始查询均用于检索，且将它们的结果相结合来生成语言模型的答案。</p>
<h4 id="查询构建">3.2.3 查询构建</h4>
<p>除文本数据外，诸如表格和图形数据等越来越多的结构化数据正被融入 RAG
系统。为适配各类数据类型，重构用户的查询很有必要。这涉及<strong>将查询转化为其他查询语言以访问替代数据源</strong>，常见方法有
Text-to-SQL 或 Text-to-Cypher 等。结构化查询语言（如
SQL、Cypher）常与语义信息和元数据结合，用于构建更复杂的查询。</p>
<h3 id="检索retrieval">3.3 检索（Retrieval）</h3>
<p>检索过程在 RAG
系统中举足轻重，提升检索效果需考虑的三个主要方面包括检索效率、质量以及任务、数据和模型的对齐。</p>
<h4 id="检索器选择">3.3.1 检索器选择</h4>
<p>随着 RAG
技术的广泛应用，嵌入模型的发展势头正盛。除基于统计的传统模型和基于编码器结构的预训练模型外，在大型语言模型上微调的嵌入模型也展现出强大的能力。然而，它们往往参数更多，导致推理和检索效率欠佳。故而，依据不同任务场景选择合适的检索器至关重要。</p>
<p><strong>稀疏检索器（Sparse
Retriever）</strong>：用统计方法将查询和文档转化为稀疏向量。其优势在于处理大型数据集时效率高，只关注非零元素。但在捕捉复杂语义方面，可能不如密集向量有效。常见方法包括
TF-IDF 和 BM25。</p>
<p><strong>密集检索器（Dense
Retriever）</strong>：使用预训练的语言模型（PLMs）为查询和文档提供密集表示。尽管计算和存储成本较高，却能提供更复杂的语义表示。典型模型有
BERT 结构的 PLMs，如 ColBERT，以及多任务微调模型，如 BGE 和 GTE 。</p>
<p><strong>混合检索器（Hybrid Retriever
）</strong>：是同时使用稀疏和密集检索器。两种嵌入技术相互补充，以提高检索效果。稀疏检索器能提供初始筛选结果。此外，稀疏模型增强了密集模型处理含罕见实体查询的零样本检索能力，从而增强系统的稳健性。</p>
<h4 id="检索器微调">3.3.2 检索器微调</h4>
<p>在上下文可能与预训练语料库有差异的情况下，尤其是在医疗保健、法律等具有大量专有术语的高度专业化领域。虽然这种调整需要额外付出努力，但能大幅提高检索效率和领域对齐度。</p>
<p><strong>监督微调（Supervised
Fine-Tuning，SFT）</strong>：基于有标记的领域数据微调检索模型通常借助对比学习来实现。这涉及缩短正样本间的距离，同时拉大负样本间的距离。</p>
<p><strong>LM 监督检索器（LM-supervised
Retriever，LSR）</strong>：与直接从数据集中构建微调数据集不同，LSR 借助
LM 生成的结果作为监督信号，在 RAG 流程中对嵌入模型进行微调。</p>
<p><strong>适配器（Adapter）</strong>：有时，对大型检索器进行微调可能成本很高，尤其是在处理像
gte-Qwen 这类基于 LLMs
的检索器时。在这种情况下，通过融入一个适配器模块并进行微调可以缓解此情况。添加适配器的另一个好处是能够更好地与特定的下游任务相适配
。</p>
<h3 id="检索后">3.4 检索后</h3>
<p>将所有检索到的块直接输入到 LLM
并非最佳选择，对块进行后处理有助于更好地利用上下文信息。主要的挑战包括：</p>
<ul>
<li>• 1）中间内容丢失（Lost in the middle）。像人类一样，LLM
往往只记得长文本的开头或结尾，而遗忘中间部分 。</li>
<li>• 2）噪声/反事实块（Noise/anti-fact
chunks）。检索到的有噪声或事实上相互矛盾的文档可能会影响最终的检索生成
。</li>
<li>• 3）上下文窗口（Context
Window）。尽管检索到了大量相关内容，但大型模型中上下文信息长度的限制导致无法涵盖所有这些内容。</li>
</ul>
<h4 id="重新排序">3.4.1 重新排序</h4>
<p>在不改变其内容或长度的情况下对检索到的块进行重新排序，以提升更关键文档块的可见性。</p>
<p><strong>规则基重新排序</strong>：依照某些规则计算指标来对块进行重新排序。常见的指标包括：多样性、相关性和
MRR（Maximal Marginal Relevance，最大边际相关性）
。其思路是减少冗余并增加结果的多样性。MRR
基于查询相关性和信息新颖性的组合标准为最终的关键短语列表选取短语。</p>
<p><strong>模型基重新排序</strong>：利用语言模型对文档块重新排序，通常依据块与查询之间的相关性。重新排序模型已成为
RAG
系统的重要组成部分，相关模型技术也在不断迭代升级。重新排序的范围还扩展到了多模态数据，比如表格和图像
。</p>
<h4 id="压缩">3.4.2 压缩</h4>
<p>在RAG流程中，人们普遍认为，尽可能多地检索相关文档，并将它们串联起来形成冗长的检索提示，是有益的。但这种认知其实是个误区。<strong>过多的上下文信息可能会带来噪声</strong>，影响大型语言模型（LLM）捕捉关键信息的能力。为了解决这个问题，通常采用压缩和筛选检索内容的方法。</p>
<p><strong>LLMLingua</strong>：利用经过对齐和训练的小语言模型，比如GPT-2
Small或LLaMA-7B，可以从提示中识别并剔除不重要的标记，将其转化为一种对人类来说晦涩难懂，但对LLMs却易于理解的形式。这种方法提供了一种直接而实用的提示压缩方式，无需对LLMs进行额外训练，同时保持了语言的完整性和压缩比的平衡。</p>
<h4 id="选择">3.4.3 选择</h4>
<p>与压缩文档内容不同，选择是直接移除无关的文档块。</p>
<p><strong>选择性上下文</strong>：通过识别并剔除输入上下文中的冗余内容，可以精炼输入，从而提升语言模型的推理效率。在实际操作中，选择性上下文根据基础语言模型计算的自信息来评估词汇单元的信息量。通过保留自信息更高的内容，这种方法提供了一种更简洁、高效的文本表示方式，且不会影响其在多样化应用中的表现。然而，这种方法<strong>忽略了压缩内容与目标语言模型以及用于提示压缩的小语言模型之间的相互依赖性</strong>。</p>
<p><strong>LLM-Critique</strong>：另一种直接而有效的方法，是在生成最终答案前，让LLM评估检索到的内容。这允许LLM通过LLM批评机制，过滤掉相关性不高的文档。例如，在Chatlaw中，LLM被引导自我推荐相关法律条款，以评估其相关性。</p>
<h3 id="生成generation">3.5 生成（Generation）</h3>
<p>利用LLM根据用户的查询和检索到的上下文信息生成答案。选择一个符合任务需求的合适模型，考虑微调需求、推理效率和隐私保护等因素。</p>
<h4 id="生成器微调">3.5.1 生成器微调</h4>
<p>除了直接使用LLM外，根据场景和数据特征进行有针对性的微调，可以带来更好的效果。这也是使用本地部署LLMs的一个显著优势。</p>
<p><strong>指令微调（Instruct-Tuning）</strong>：当LLMs在特定领域缺少数据时，可以通过微调为其提供额外的知识。通用的微调数据集可以作为第一步。微调的另一个好处是能够调整模型的输入和输出，例如，使LLM适应特定的数据格式，并根据指令以特定风格生成响应。</p>
<p><strong>强化学习（Reinforcement
learning）</strong>：通过强化学习来让大型语言模型（LLM）的输出与人类或检索器的偏好相契合，是一种颇具潜力的方法。例如，对最终生成的答案进行手动标注，然后借助强化学习给予反馈。除了与人类的偏好达成一致，与微调模型和检索器的偏好相符合也是可行的。</p>
<p><strong>双重微调（Dual
Fine-tuing）</strong>：同时对生成器和检索器进行微调，以实现它们偏好的一致。一种典型的方式，如
RA-DIT，利用 KL 散度来对齐检索器和生成器之间的评分函数。</p>
<h4 id="验证verification">3.5.2 验证（Verification）</h4>
<p>尽管 RAG
提升了大型语言模型生成答案的可靠性，但在众多场景中，它需要将幻觉出现的概率降至最低。因此，可以通过额外的验证模块来筛除不符合要求标准的响应。常见的验证方法包含基于知识库的和基于模型的。</p>
<p><strong>知识库验证</strong>：通过外部知识直接对大型语言模型生成的响应进行验证。通常，先从响应中提取特定的陈述或三元组。而后，从经过验证的知识库（如维基百科或特定的知识图谱）中检索相关证据。最后，将每个陈述与证据逐步比对，以判定该陈述是得到支持、被驳斥还是信息不足。</p>
<p><strong>基于模型的验证</strong>：运用小型语言模型来验证大型语言模型生成的响应。给定输入问题、检索到的知识和生成的答案，训练一个小型语言模型来判别生成的答案是否正确反映了检索到的知识。此过程被设定为一道选择题，验证器需要判断答案是否反映了正确答案。如果生成的答案未正确反映检索到的知识，可迭代地重新生成答案，直至验证器确认答案正确。</p>
<h3 id="编排orchestration">3.6 编排（Orchestration）</h3>
<p>编排涉及管理 RAG 过程的控制模块。与传统固定流程的僵化方式不同，RAG
如今在关键节点纳入决策，并依据先前的结果动态选择后续步骤。这种自适应和模块化的能力是模块化
RAG 的显著特征，使其有别于更为简单的朴素和高级 RAG 范式。</p>
<h4 id="路由">3.6.1 路由</h4>
<p>面对不同的查询，RAG
系统会路由到为不同场景定制的特定管道，这是为应对各种情况而设计的多功能
RAG
架构的基本特性。需要一个决策机制，依据来自模型的输入或补充的元数据，来确定将启用哪些模块。针对不同的提示或组件采用不同的路由。</p>
<h4 id="调度">3.6.2 调度</h4>
<p>RAG
系统在复杂性和适应性方面不断演进，能够借助复杂的调度模块来管理流程。调度模块在模块化
RAG
中发挥着关键作用，能识别需要外部数据检索的关键节点，<strong>评估响应的充分性，并决定是否需要进一步的调查</strong>。它通常用于涉及递归、迭代和自适应检索的场景，确保系统能就何时停止生成或启动新的检索循环做出明智决策。</p>
<p><strong>规则判断（Metadata
routing）</strong>：后续步骤由一组既定规则支配。通常，系统通过评分机制评估生成答案的质量。继续或停止该过程的决策取决于这些分数是否超过某些预定阈值，这些阈值通常与单个token的置信水平有关，接受
的条件是其中的所有令牌必须具有大于或等于阈值的相关概率。若不满足此条件，系统会重新生成新答案。</p>
<p><strong>LLM 判断（Semantic routing）</strong>。LLM
独立决定后续的行动。有两种主要方式来实现这种能力：</p>
<ul>
<li>• 第一种方式利用 LLM
的上下文学习能力，并通过提示工程进行判断。这种方式的一个显著优点是无需对模型进行微调。然而，判断输出的格式取决于
LLM 对所提供指令的遵循情况。</li>
<li>• 第二种方式涉及 LLM
生成特定token，通过微调来启动有针对性的行动。这种技术源自 Toolformer
，已被集成到像 Self-RAG 这样的框架中。这使得对 LLM
的行动有了更直接的控制机制，增强了系统对对话上下文中特定触发因素的响应能力。不过，它需要生成大量符合要求的指令集来微调
LLM。</li>
</ul>
<p><strong>知识驱动的调度策略（Knowledge-guide
schedulin）</strong>：突破了基于规则的方法的局限，也不再完全依赖大型语言模型（LLM）来控制流程，而是采用了一种更为灵活的中间策略——知识引导的调度。通过知识图谱的强大功能，引导检索和生成过程。从知识图谱中提取与问题相关的信息，构建一个由逻辑上相互关联的节点组成的推理链，每个节点都承载着解决问题的关键信息。基于这一推理链的节点信息，可以分别进行信息检索和内容生成。整合这种方法，不仅提升了问题解决的效率和精确度，也使得提供的解释更加清晰明了。</p>
<h4 id="融合">3.6.3 融合</h4>
<p>随着RAG进程的发展，已经超越了单一的线性流程，经常需要扩大检索范围或通过探索多条流水线来增加多样性。在扩展到各个分支之后，融合模块有效地整合了信息，确保了全面且连贯的响应。融合模块的作用不仅仅是合并答案，还要确保最终输出内容丰富，并且能够反映出问题的多维度特性。</p>
<p><strong>LLM融合（LLM
fusion）</strong>：将多分支的信息聚合起来最直接的方法之一是利用LLMs的强大功能来分析和整合不同分支的信息。然而，这种方法在处理超出LLM上下文窗口限制的长答案时也面临挑战。为了解决这个问题，通常的做法是先对每个分支的答案进行总结，提取关键信息，然后再将其输入到LLM中，以确保即使在长度受限的情况下也能保留最重要的内容。</p>
<p><strong>加权集成（Weighted ensemble
）</strong>：从多个分支生成的不同标记的加权值，以实现对最终输出的全面选择。权重是根据文档与输入查询之间的相似性得分来确定的。权重通过使用softmax函数来计算，确保了权重的归一化，并且总和为一。</p>
<p><strong>互反排名融合（RRF ，Reciprocal Rank
Fusion）</strong>：将多个检索结果的排名合并成一个统一的列表。它采用定制的加权平均方法来提高整体的预测性能和排名精度。优势在于其动态权重分配，这种分配是由分支之间的相互作用所决定的。在模型或来源的异质性特别显著的场景中，RRF尤其有效，它可以显著提高预测的准确性。</p>
<h2 id="rag-流与流模式">4. RAG 流与流模式</h2>
<p>模块化的 RAG
流能够分解为子函数的图。通过控制逻辑，运算符能够在预设的管道中执行，同时在必要时进行条件、分支或循环操作。在最简单的情形下，该图为一个线性链。</p>
<h3 id="线性模式linear-pattern">4.1 线性模式（Linear Pattern）</h3>
<figure>
<img
src="https://mmbiz.qpic.cn/mmbiz_png/ZPAyBwf6Hyj1RN6oLRRFiawc94IDAXSL0X3OcoTlK3KMg9xgIiasnGKDdSDqnOlxB6GhkFKc1TlWBSgnvhQLzE8w/640?wx_fmt=png&amp;from=appmsg&amp;tp=wxpic&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" srcset="/img/loading.gif" lazyload
alt="图片" />
<figcaption aria-hidden="true">图片</figcaption>
</figure>
<p>常见的线性 RAG 流在预检索阶段涉及查询转换模块（例如重写或 HyDE
运算符），并在检索后阶段运用重新排序。重写 - 检索 -
读取（RRR）是一种典型的线性结构。</p>
<figure>
<img
src="https://mmbiz.qpic.cn/mmbiz_png/ZPAyBwf6Hyj1RN6oLRRFiawc94IDAXSL0dtdlGfG0JklzLfBTbUH5XQwMXO5BsoLrCZl1XE1IJGsEbcsS92jUMw/640?wx_fmt=png&amp;from=appmsg&amp;tp=wxpic&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" srcset="/img/loading.gif" lazyload
alt="图片" />
<figcaption aria-hidden="true">图片</figcaption>
</figure>
<p>如上图所示，查询重写模块 te 是在 T5-large
上微调的较小的可训练语言模型，在强化学习的背景下，重写器的优化被形式化为马尔可夫决策过程，LLM
的最终输出作为奖励。检索器采用稀疏编码模型，BM25。</p>
<h3 id="条件模式conditional-pattern">4.2 条件模式（Conditional
Pattern）</h3>
<figure>
<img
src="https://mmbiz.qpic.cn/mmbiz_png/ZPAyBwf6Hyj1RN6oLRRFiawc94IDAXSL0ybg1eUz9ibxYtqRUryrYDtoaYXJlOarxic56MulDg39XIV5MJtKbN8Ww/640?wx_fmt=png&amp;from=appmsg&amp;tp=wxpic&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" srcset="/img/loading.gif" lazyload
alt="图片" />
<figcaption aria-hidden="true">图片</figcaption>
</figure>
<p>具有条件结构的 RAG 流涉及依据不同条件选取不同的 RAG
管道，如上图所示。管道的选择是通过路由模块实现的，该模块决定流中的下一个模块。</p>
<p>例如，对于与严肃问题、政治事务或娱乐主题相关的问题，对大型语言模型生成的响应的容忍度各不相同。这些路由流在检索源、检索过程、配置、模型和提示等方面常常存在差异。</p>
<h3 id="分支branching">4.3 分支（Branching）</h3>
<p>在许多情况下，RAG
流系统可能存在多个并行运行的分支，通常是为了增加生成结果的多样性。</p>
<p>预检索分支化（多查询并行检索）：</p>
<figure>
<img
src="https://mmbiz.qpic.cn/mmbiz_png/ZPAyBwf6Hyj1RN6oLRRFiawc94IDAXSL0OQohT9XMxibicxOYRawPNmq0MPUVpf7fcT5aAefnvZKfG3pOuzhUBRrw/640?wx_fmt=png&amp;from=appmsg&amp;tp=wxpic&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" srcset="/img/loading.gif" lazyload
alt="图片" />
<figcaption aria-hidden="true">图片</figcaption>
</figure>
<p>后检索分支化（单查询并行生成）：</p>
<figure>
<img
src="https://mmbiz.qpic.cn/mmbiz_png/ZPAyBwf6Hyj1RN6oLRRFiawc94IDAXSL0bGKGLN3QTyI1EEtPAvnH6LXKhggOVIRfBPosjHpNTmtPA1QtJ8HmSw/640?wx_fmt=png&amp;from=appmsg&amp;tp=wxpic&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" srcset="/img/loading.gif" lazyload
alt="图片" />
<figcaption aria-hidden="true">图片</figcaption>
</figure>
<p>REPLUG
展现了一种典型的后检索分支化架构，它预测了每个分支上每个标记的概率。通过加权可能性的集成，各分支结果被综合起来，最终生成的输出用于通过反馈机制对检索器进行微调，这个检索器被称为Contriever。</p>
<figure>
<img
src="https://mmbiz.qpic.cn/mmbiz_png/ZPAyBwf6Hyj1RN6oLRRFiawc94IDAXSL0aKrTBhBCgT8ApTddibMmcUQaeiaQuM3RAZZ1ToYgEfU6ccYz07F4knKg/640?wx_fmt=png&amp;from=appmsg&amp;tp=wxpic&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" srcset="/img/loading.gif" lazyload
alt="图片" />
<figcaption aria-hidden="true">图片</figcaption>
</figure>
<h3 id="循环模式loop-pattern">4.4 循环模式（Loop Pattern）</h3>
<p>具有<strong>循环结构的 RAG 流，是模块化 RAG
的一项重要特性</strong>，涵盖相互依存的检索与生成步骤，也包含用于流程控制的调度模块。</p>
<figure>
<img
src="https://mmbiz.qpic.cn/mmbiz_png/ZPAyBwf6Hyj1RN6oLRRFiawc94IDAXSL0KyHYzoIXlibUQYOichcgFq5sNVR3iaWpW7CmUv7GzbdGgmiahFoq5V1niaw/640?wx_fmt=png&amp;from=appmsg&amp;tp=wxpic&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" srcset="/img/loading.gif" lazyload
alt="图片" />
<figcaption aria-hidden="true">图片</figcaption>
</figure>
<p>循环模式可进一步划分为迭代、递归和自适应（主动）检索方式。</p>
<h4 id="迭代检索iterative-retrieval">4.4.1 迭代检索（Iterative
retrieval）</h4>
<p>单次的检索和生成或许无法有效处理需要大量知识的复杂问题，所以RAG
中能采用迭代方法，包含固定数量的检索迭代。</p>
<figure>
<img
src="https://mmbiz.qpic.cn/mmbiz_png/ZPAyBwf6Hyj1RN6oLRRFiawc94IDAXSL0k0rTRA4FB4jKOmOK06pFtjNEXuAhIOd6yrOIXTMJQmZRcWckH7vBVA/640?wx_fmt=png&amp;from=appmsg&amp;tp=wxpic&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" srcset="/img/loading.gif" lazyload
alt="图片" />
<figcaption aria-hidden="true">图片</figcaption>
</figure>
<p>迭代检索的一个典型示例为 ITER-RETGEN
（如上图），它对检索增强生成和生成增强检索进行迭代。检索增强生成基于所有检索到的知识针对任务输入给出响应。在每次迭代中，ITER-RETGEN
借助前一次迭代的模型输出作为特定情境来辅助检索更多相关知识。循环的终止由预先设定的迭代次数决定。</p>
<h4 id="递归检索recursive-retrieval">4.4.2 递归检索（Recursive
retrieval）</h4>
<p>与迭代检索不同，递归检索的显著特点在于其对前一步骤的明确依赖以及检索的不断深入。通常，它遵循树状结构，并且具备清晰的终止机制作为递归检索的退出条件。</p>
<figure>
<img
src="https://mmbiz.qpic.cn/mmbiz_png/ZPAyBwf6Hyj1RN6oLRRFiawc94IDAXSL0GBr2ZSuNtn8ymTVsW2BkGZ0YM7LOrg6AvTTR9CIIXtzib2hLc4xf8uA/640?wx_fmt=png&amp;from=appmsg&amp;tp=wxpic&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" srcset="/img/loading.gif" lazyload
alt="图片" />
<figcaption aria-hidden="true">图片</figcaption>
</figure>
<p>在 RAG
系统中，递归检索通常涉及查询变换，依靠每次检索时新重写的查询。递归检索的一个典型实现如
ToC，涉及递归执行 RAC（递归增强澄清，Recursive Augmented
Clarification），从初始的模糊问题（AQ，ambiguous
question）逐步将子节点插入到澄清树中。在每个扩展步骤，依据当前查询对段落进行重新排序以生成明确的问题（DQ，disambiguous
Question）。当达到最大有效节点数或最大深度时，对树的探索便告结束。一旦构建好澄清树，ToC
收集所有有效节点并生成一个全面的长文本答案来解决 AQ。</p>
<h4 id="自适应主动检索adaptive-active-retrieval">4.4.3
自适应（主动）检索（Adaptive (Active) retrieval）</h4>
<p>随着 RAG
的发展，逐渐从被动检索转向了自适应检索的出现，也就是主动检索，这在一定程度上得益于
LLM 的强大能力。它与 LLM 代理有着相同的核心概念。RAG
系统能够主动确定检索的时机，并决定何时结束整个流程并得出最终结果。依照判断标准，这可进一步细分为基于提示和基于调整的方法。</p>
<h4 id="基于提示prompt-base">4.4.3.1 基于提示（Prompt-base）</h4>
<figure>
<img
src="https://mmbiz.qpic.cn/mmbiz_png/ZPAyBwf6Hyj1RN6oLRRFiawc94IDAXSL0SfvUFibqI1ibypmC6xZuFDJYmeb7zia93sckVWIrlzOqwpX5eLGh1Nd4g/640?wx_fmt=png&amp;from=appmsg&amp;tp=wxpic&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" srcset="/img/loading.gif" lazyload
alt="图片" />
<figcaption aria-hidden="true">图片</figcaption>
</figure>
<p>基于提示的方法借助提示工程来掌控流程并引导 LLM。一个典型的实现案例是
FLARE 。其核心观念在于，LLM
仅在缺乏必要知识时才进行检索，从而避免在增强的 LM
中出现不必要或不恰当的检索。FLARE
会迭代生成下一个临时句子，并检查是否存在低概率标记。若有，系统便会检索相关文档并重新生成句子。</p>
<h4 id="基于微调tuning-base">4.4.3.2 基于微调（Tuning-base）</h4>
<p>基于调整的方法涉及微调 LLM
以生成特殊标记，进而触发检索或生成。这一概念可追溯至 Toolformer
，其中特定内容的生成有助于调用工具。在 RAG
系统中，此方法用于控制检索和生成步骤。</p>
<figure>
<img
src="https://mmbiz.qpic.cn/mmbiz_png/ZPAyBwf6Hyj1RN6oLRRFiawc94IDAXSL0QPNK61vjbnHyl6OQ0N7hBq5icqP9SKzQ1me4KW3BWOxSVib5vFwnENbg/640?wx_fmt=png&amp;from=appmsg&amp;tp=wxpic&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" srcset="/img/loading.gif" lazyload
alt="图片" />
<figcaption aria-hidden="true">图片</figcaption>
</figure>
<p>一个典型例子是
Self-RAG。给定输入提示和先前的生成结果，首先预测特殊标记“检索”是否有助于通过检索来增强继续生成。然后，若需要检索，模型会生成一个评判标记来评估检索到的段落的相关性，以及一个评判标记来评估响应中的信息是否得到检索到的段落的支持。最后，一个评判标记评估响应的整体效用，并选取最优结果作为最终输出。</p>
<h3 id="微调模式tuning-pattern">4.5 微调模式（Tuning Pattern）</h3>
<p>RAG 持续与更多与 LLM 相关的技术相融合。在模块化 RAG
中，许多组件由可训练的语言模型构成。通过微调，能够进一步优化组件的性能以及与整体流程的兼容性。</p>
<p>微调阶段的三种主要模式，即检索器微调、生成器微调以及双重微调。</p>
<h4 id="检索器微调-1">4.5.1 检索器微调</h4>
<figure>
<img
src="https://mmbiz.qpic.cn/mmbiz_png/ZPAyBwf6Hyj1RN6oLRRFiawc94IDAXSL0icfV6YLiaeaHdKGMXJOcQFOF2uIWc2IPicz9HyAO7HUGzN2NxYUa3MlBw/640?wx_fmt=png&amp;from=appmsg&amp;tp=wxpic&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" srcset="/img/loading.gif" lazyload
alt="图片" />
<figcaption aria-hidden="true">图片</figcaption>
</figure>
<p>在 RAG 流程中，微调检索器的常见方法如上图，其中包括：</p>
<ul>
<li>•
1.对检索器进行直接的监督微调。构建专门用于检索的数据集，并对密集检索器进行微调。例如，使用开源检索数据集或依据特定领域数据构建一个。</li>
<li>• 2.添加可训练的适配器模块。有时，直接微调 API 基础嵌入模型（如
OpenAI Ada-002 和
Cohere）是行不通的。引入适配器模块能够增强数据的表示。此外，适配器模块有助于更好地与下游任务对齐，无论是针对特定任务（如
PRCA ）还是通用目的（如 AAR ）。</li>
<li>• 3.LM 监督检索（LSR）。依据 LLM 生成的结果对检索器进行微调。</li>
<li>• 4.LLM 奖励 RL。将 LLM
输出结果作为监督信号。采用强化学习使检索器与生成器对齐。整个检索过程以生成马尔可夫链的形式拆解。</li>
</ul>
<h4 id="生成器微调-1">4.5.2 生成器微调</h4>
<figure>
<img
src="https://mmbiz.qpic.cn/mmbiz_png/ZPAyBwf6Hyj1RN6oLRRFiawc94IDAXSL0L2dBawrWmlicammz8HHA8GJWvZW9SjHytw4icJmRvSiaghhzRSuCPRO8Q/640?wx_fmt=png&amp;from=appmsg&amp;tp=wxpic&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" srcset="/img/loading.gif" lazyload
alt="图片" />
<figcaption aria-hidden="true">图片</figcaption>
</figure>
<p>在RAG流程中，对生成器进行微调的几种主要方法包括：</p>
<ul>
<li>• 直接监督式微调（Direct supervised
fine-tuning）：利用外部数据集进行微调，能够为生成器注入新知识，并且还能定制化输入输出格式。通过设定问答模式，大型语言模型（LLM）能够理解特定的数据格式，并按照指令进行输出。</li>
<li>•
蒸馏（Distillation）：在本地部署开源模型时，一种简单有效的优化手段是利用GPT-4批量创建微调数据，以此提升开源模型的性能。</li>
<li>• 基于LLM/人类反馈的强化学习（RL from LLM/human
feedback）：通过最终生成的答案反馈进行强化学习，不仅可以利用人类的评估，还能借助强大的LLMs作为评价的裁判。</li>
</ul>
<h4 id="双重微调">4.5.3 双重微调</h4>
<p>RAG系统中的一大特色是能够同时对检索器和生成器进行微调。系统微调的核心在于检索器与生成器之间的协同配合。例如，RA-DIT就是一个典范，它对LLM和检索器都进行了微调。LM-ft组件负责更新LLM，以提高在检索增强指令辅助下得出正确答案的可能性；而R-ft组件则负责更新检索器，以减少检索器得分分布与LLM偏好之间的KL散度差异。</p>

                
              </div>
            
            <hr/>
            <div>
              <div class="post-metas my-3">
  
  
</div>


              
  

  <div class="license-box my-3">
    <div class="license-title">
      <div></div>
      <div>https://linxkon.github.io/全面系统了解RAG的发展历史与创新.html</div>
    </div>
    <div class="license-meta">
      
        <div class="license-meta-item">
          <div>作者</div>
          <div>linxkon</div>
        </div>
      
      
        <div class="license-meta-item license-meta-date">
          <div>发布于</div>
          <div>2024年8月17日</div>
        </div>
      
      
      
        <div class="license-meta-item">
          <div>许可协议</div>
          <div>
            
              
              
                <a class="print-no-link" target="_blank" href="https://creativecommons.org/licenses/by/4.0/">
                  <span class="hint--top hint--rounded" aria-label="BY - 署名">
                    <i class="iconfont icon-by"></i>
                  </span>
                </a>
              
            
          </div>
        </div>
      
    </div>
    <div class="license-icon iconfont"></div>
  </div>



              
                <div class="post-prevnext my-3">
                  <article class="post-prev col-6">
                    
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/%E5%A4%A7%E5%9E%8B%E8%AF%AD%E8%A8%80%E6%A8%A1%E5%9E%8B%E8%AE%AD%E7%BB%83%E5%B7%A5%E4%BD%9C%E6%B5%81.html" title="大型语言模型LLM训练流程详解">
                        <span class="hidden-mobile">大型语言模型LLM训练流程详解</span>
                        <span class="visible-mobile">下一篇</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
  
  
    <article id="comments" lazyload>
      
  <div id="gitalk-container"></div>
  <script type="text/javascript">
    Fluid.utils.loadComments('#gitalk-container', function() {
      Fluid.utils.createCssLink('/css/gitalk.css')
      Fluid.utils.createScript('https://lib.baomitu.com/gitalk/1.8.0/gitalk.min.js', function() {
        var options = Object.assign(
          {"clientID":"Ov23licg1p15oAGiQtDC","clientSecret":"d6ca3873752e3a6eb2d21a98b92a3021fd462cbf","repo":"Waline","owner":"linxkon","admin":["linxkon"],"language":"zh-CN","labels":["Gitalk"],"perPage":10,"pagerDirection":"last","distractionFreeMode":false,"createIssueManually":true,"proxy":"https://cors-anywhere.azm.workers.dev/https://github.com/login/oauth/access_token"},
          {
            id: '04523392bb053e39d153ec3994d05eb6'
          }
        )
        var gitalk = new Gitalk(options);
        gitalk.render('gitalk-container');
      });
    });
  </script>
  <noscript>Please enable JavaScript to view the comments</noscript>


    </article>
  


          </article>
        </div>
      </div>
    </div>

    <div class="side-col d-none d-lg-block col-lg-2">
      
  <aside class="sidebar" style="margin-left: -1rem">
    <div id="toc">
  <p class="toc-header">
    <i class="iconfont icon-list"></i>
    <span>目录</span>
  </p>
  <div class="toc-body" id="toc-body"></div>
</div>



  </aside>


    </div>
  </div>
</div>





  



  



  



  



  







    

    
      <a id="scroll-top-button" aria-label="TOP" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v" for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>

    

    
  </main>

  <footer>
    <div class="footer-inner">
  
    <div class="footer-content">
       <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a> 
    </div>
  
  
    <div class="statistics">
  
  

  
    
      <span id="leancloud-site-pv-container" style="display: none">
        总访问量
        <span id="leancloud-site-pv"></span>
        次
      </span>
    
    
      <span id="leancloud-site-uv-container" style="display: none">
        访客量
        <span id="leancloud-site-uv"></span>
        次
      </span>
    
    

  
</div>

  
  
  
</div>

  </footer>

  <!-- Scripts -->
  
  <script  src="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://lib.baomitu.com/jquery/3.6.4/jquery.min.js" ></script>
<script  src="https://lib.baomitu.com/twitter-bootstrap/4.6.1/js/bootstrap.min.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>


  <script  src="https://lib.baomitu.com/typed.js/2.0.12/typed.min.js" ></script>
  <script>
    (function (window, document) {
      var typing = Fluid.plugins.typing;
      var subtitle = document.getElementById('subtitle');
      if (!subtitle || !typing) {
        return;
      }
      var text = subtitle.getAttribute('data-typed-text');
      
        typing(text);
      
    })(window, document);
  </script>




  
    <script  src="/js/img-lazyload.js" ></script>
  




  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/tocbot/4.20.1/tocbot.min.js', function() {
    var toc = jQuery('#toc');
    if (toc.length === 0 || !window.tocbot) { return; }
    var boardCtn = jQuery('#board-ctn');
    var boardTop = boardCtn.offset().top;

    window.tocbot.init(Object.assign({
      tocSelector     : '#toc-body',
      contentSelector : '.markdown-body',
      linkClass       : 'tocbot-link',
      activeLinkClass : 'tocbot-active-link',
      listClass       : 'tocbot-list',
      isCollapsedClass: 'tocbot-is-collapsed',
      collapsibleClass: 'tocbot-is-collapsible',
      scrollSmooth    : true,
      includeTitleTags: true,
      headingsOffset  : -boardTop,
    }, CONFIG.toc));
    if (toc.find('.toc-list-item').length > 0) {
      toc.css('visibility', 'visible');
    }

    Fluid.events.registerRefreshCallback(function() {
      if ('tocbot' in window) {
        tocbot.refresh();
        var toc = jQuery('#toc');
        if (toc.length === 0 || !tocbot) {
          return;
        }
        if (toc.find('.toc-list-item').length > 0) {
          toc.css('visibility', 'visible');
        }
      }
    });
  });
</script>


  <script src=https://lib.baomitu.com/clipboard.js/2.0.11/clipboard.min.js></script>

  <script>Fluid.plugins.codeWidget();</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/anchor-js/4.3.1/anchor.min.js', function() {
    window.anchors.options = {
      placement: CONFIG.anchorjs.placement,
      visible  : CONFIG.anchorjs.visible
    };
    if (CONFIG.anchorjs.icon) {
      window.anchors.options.icon = CONFIG.anchorjs.icon;
    }
    var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
    var res = [];
    for (var item of el) {
      res.push('.markdown-body > ' + item.trim());
    }
    if (CONFIG.anchorjs.placement === 'left') {
      window.anchors.options.class = 'anchorjs-link-left';
    }
    window.anchors.add(res.join(', '));

    Fluid.events.registerRefreshCallback(function() {
      if ('anchors' in window) {
        anchors.removeAll();
        var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
        var res = [];
        for (var item of el) {
          res.push('.markdown-body > ' + item.trim());
        }
        if (CONFIG.anchorjs.placement === 'left') {
          anchors.options.class = 'anchorjs-link-left';
        }
        anchors.add(res.join(', '));
      }
    });
  });
</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js', function() {
    Fluid.plugins.fancyBox();
  });
</script>


  <script>Fluid.plugins.imageCaption();</script>

  <script defer src="/js/leancloud.js" ></script>

  <script  src="/js/local-search.js" ></script>





<!-- 主题的启动项，将它保持在最底部 -->
<!-- the boot of the theme, keep it at the bottom -->
<script  src="/js/boot.js" ></script>


  

  <noscript>
    <div class="noscript-warning">博客在允许 JavaScript 运行的环境下浏览效果更佳</div>
  </noscript>
<script type="text/x-mathjax-config">
    MathJax.Hub.Config({
        tex2jax: {
            inlineMath: [ ["$","$"], ["\\(","\\)"] ],
            skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code'],
            processEscapes: true
        }
    });
    MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax();
        for (var i = 0; i < all.length; ++i)
            all[i].SourceElement().parentNode.className += ' has-jax';
    });
</script>
<!-- <script src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script> -->
<script id="MathJax-script" async
  src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-svg-full.js">
</script>
</body>
</html>
